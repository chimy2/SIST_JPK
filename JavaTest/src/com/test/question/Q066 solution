/*

안녕하세요.

이 코드에서 핵심은 13번에서 23번 라인까지입니다.
아래로는 단순 출력하는 부분이니 넘어가고, 중복값이 제거되는 흐름을 알려드릴께요.
list는 총 6개의 정수값이 들어가는 배열입니다. 배열의 인덱스는 0부터 시작합니다.
13번줄에 첫번째 for문은 이 인덱스를 담당하는 반복문입니다.
i값이 0부터 시작해서 5번까지 1씩 증가하며 반복을 하게 됩니다.
그전에 for문의 동작방식은 이해하고 계시죠?


for(초기식 ; 조건식 ; 증감식 ) { 실행내용 }


이런식으로 작성이 되고, 실행순서는 초기식은 처음 한번만 실행이 되고,
다음 조건식을 수행하고 만족하면 {실행내용}을 실행하고 다음 증감식 수행후 
다시 조건식을 비교하게 됩니다. 만족하게 되면 위의 순서를 반복하고, 아니라면 for문을 빠져나오게 됩니다.

​첫번째 for문이 시작되므로 i=0 부터 시작합니다. 이 i 값은 배열의 인덱스, 즉 순서입니다.
먼저 0번인덱스(첫번째값)에 랜덤값을 만들어서 저장합니다.
그리고 이 값이 중복인지 확인을 해야 하는데, 두번째 for문이 그 작업을 합니다.

​두번째 for문은 첫번째 값부터 이전값까지 같은 값이 있는지 비교를 하게 됩니다.
만약 i=3이라면 순서로는 4번째 값이 되지요.
그럼 이 4번째 값이 첫번째, 두번째, 세번째 값과 같은지 비교를 하게 됩니다.
그래서 j라는 변수는 현재를 기준으로 앞쪽 인덱스를 반복하기 위한 변수입니다.
i=3 일때는 j=0, 1, 2 까지 반복이 되지요.
i=0일때는 j<i 조건을 보면 0<0 이 되므로 조건이 만족하지 않습니다. 그래서 두번째 for문이 실행되지 않지요.

​첫번째 값이므로 이전값이 없습니다. 중복될 일이 없지요. 그래서 중복 비교를 위한  for문이 실행되지 않고,
i=1일때는 두번째 값이므로 첫번째 값과 비교해야 합니다.
j=0 일때까지 반복합니다. list[1](현재값) 과 list[0](앞쪽값)과 비교를 해서 만족하지 않는다면 중복값이 없다는
의미이므로 별다른 작업없이 반복만 하다 끝나게 됩니다.

​예를 들어 i=3 인상태이고, 비교를 하다가 j=2번과 같은 값이 발생했다고 하면,
i=3 인 값, 즉, 4번째에 새로운 값을 받아야 합니다.
중복이 생기는 경우 i--; 를 해주게 되는데,
i--를 안하게 되면, 현재 for문이 실행되고 나면, 다음 증감식이 실행됩니다. i++가 실행되지요.
그래서 i=4가 되고, 여기에 새로운 값이 들어가게 되지요.
우리는 i=3 에 있는 값이 중복이므로 여기에 값을 다시 넣어야 합니다.

그런데 for문이 실행되고 나면 i값이 1 증가하므로, 여기에서 미리 1을 감소시켜주는것이지요.
그럼 i=3 상태에서 i--; 를 하면 i=2가 되고,
for문 실행문장이 종료되고, 증감식이 수행되어 i=3 이 되고, 여기에 새로운 난수값을 받게 됩니다.

​이런 원리로 수행이 되고,
i--; 다음 break; 문은 이미 중복 값이라고 판정이 되었기 때문에 그 뒤에 있는 값들은 비교할 필요가 없지요.
그래서 두번째 for문을 바로 빠져나오기 위해 사용된 break;문 입니다.

​




























*/






